//لعبة الثعبان الجائع الكلاسيكيةعادت من جديد بشكل اخر في قناة الورشة 
//التصميم و المخطط و الكود بحسابي على gethub 
//
#include "LedControl.h" // مكتبة LedControl تُستخدم للتحكم في مصفوفة LED. يمكن العثور عليها باستخدام مدير المكتبات أو تنزيلها كملف مضغوط من هنا: https://github.com/wayoda/LedControl

// --------------------------------------------------------------- //
// ------------------------- إعدادات المستخدم --------------------- //
// --------------------------------------------------------------- //

// تعريف النغمات الموسيقية (ترددات النوتات)
const int c = 261;
const int d = 294;
const int e = 329;
const int f = 349;
const int g = 391;
const int gS = 415;
const int a = 440;
const int aS = 466;
const int b = 494;
const int cH = 523;
const int cSH = 554;                 
const int dH = 587;
const int dSH = 622;
const int eH = 659;
const int fH = 698;
const int fSH = 740;
const int gH = 784;
const int gSH = 830;
const int aH = 880;

// تم تعريف جميع الأرجل (المخارج) هنا
struct Pin {
  static const short joystickX = A2;   // منفذ عصا التحكم محور X
  static const short joystickY = A3;   // منفذ عصا التحكم محور Y
  static const short joystickVCC = 15; // مزود طاقة افتراضي لعصا التحكم (المدخل التناظري 1) لجعل عصا التحكم قابلة للتوصيل مباشرة بجانب الأردوينو نانو VCC
  static const short joystickGND = 14; // أرضي افتراضي لعصا التحكم (المدخل التناظري 0) لجعل عصا التحكم قابلة للتوصيل مباشرة بجانب الأردوينو نانو GND

  static const short potentiometer = A5; // مقياس الجهد للتحكم في سرعة الثعبان

  static const short CLK = 10;   // إشارة الساعة لمصفوفة LED
  static const short CS  = 11;   // إشارة اختيار الشريحة لمصفوفة LED
  static const short DIN = 12;   // إدخال البيانات لمصفوفة LED
  
  static const short buzzerPin = 6;  // منفذ الجرس (البيزر)
};

// سطوع مصفوفة LED: يتراوح بين 0 (أكثر ظلمة) و 15 (أكثر سطوعًا)
const short intensity = 4;

// كلما كان الرقم أصغر، كلما كان تمرير الرسالة أسرع
const short messageSpeed = 4;

// الطول الابتدائي للثعبان (1...63، يُوصى بـ 3)
const short initialSnakeLength = 3;

// --------------------------------------------------------------- //
// ------------------------- الإعدادات الأولية -------------------- //
// --------------------------------------------------------------- //

void setup() {
  Serial.begin(115200);  // تعيين معدل البود على شاشة المراقبة التسلسلية
  initialize();         // تهيئة المنافذ ومصفوفة الليدات
  calibrateJoystick(); // معايرة وضع عصا التحكم الأساسي (لا تلمسها)
  showSnakeMessage(); // عرض رسالة (SNAKE)
  startSound();      // تشغيل صوت البداية
}

// --------------------------------------------------------------- //
// ------------------------- الحلقة الرئيسية ---------------------- //
// --------------------------------------------------------------- //

void loop() {
  generateFood();    // إذا لم يكن هناك طعام، قم بإنشائه، وتحقق أيضًا من حالة الفوز
  scanJoystick();    // مراقبة تحركات عصا التحكم ولمعان الطعام
  calculateSnake();  // حساب تحركات الثعبان
  handleGameStates(); // إدارة حالات اللعبة (الفوز أو الخسارة)

  // قم بإلغاء التعليق إذا كنت تريد طباعة لوحة اللعبة الحالية إلى المنفذ التسلسلي (قد يؤدي إلى إبطاء اللعبة قليلاً)
  // dumpGameBoard(); 
}

// --------------------------------------------------------------- //
// -------------------- المتغيرات المساعدة ---------------------- //
// --------------------------------------------------------------- //

LedControl matrix(Pin::DIN, Pin::CLK, Pin::CS, 1);

struct Point {
  int row = 0, col = 0;
  Point(int row = 0, int col = 0): row(row), col(col) {}
};

struct Coordinate {
  int x = 0, y = 0;
  Coordinate(int x = 0, int y = 0): x(x), y(y) {}
};

bool win = false;      // حالة الفوز
bool gameOver = false; // حالة انتهاء اللعبة

// إحداثيات رأس الثعبان (سيتم توليدها عشوائيًا)
Point snake;

// الطعام غير موجود في أي مكان بعد
Point food(-1, -1);

// إحداثيات عصا التحكم في الوضع الأساسي (سيتم تعيينها أثناء المعايرة)
Coordinate joystickHome(500, 500);

// معلمات الثعبان
int snakeLength = initialSnakeLength; // الطول الابتدائي للثعبان
int snakeSpeed = 1; // السرعة الحالية للثعبان (سيتم تعيينها بناءً على قيمة مقياس الجهد)
int snakeDirection = 0; // اتجاه الثعبان (0 يعني عدم الحركة)

// ثوابت الاتجاهات
const short up     = 1;
const short right  = 2;
const short down   = 3; // 'down - 2' يجب أن يكون 'up'
const short left   = 4; // 'left - 2' يجب أن يكون 'right'

// الحد الأدنى لحركة عصا التحكم ليتم اعتبارها
const int joystickThreshold = 200;

// التدرج اللوغاريتمي لمقياس الجهد (-1 = خطي، 1 = طبيعي، أكبر = أكثر حدة)
const float logarithmity = 0.4;

// مصفوفة العمر: تحتفظ بـ "عمر" كل بكسل في المصفوفة. إذا كان العمر > 0، فإن البكسل مضاء.
// في كل إطار، يتم زيادة عمر جميع البكسلات المضاءة.
// عندما يتجاوز عمر بعض البكسلات طول الثعبان، يتم إطفاؤها.
// يتم إضافة عمر 1 في اتجاه الثعبان الحالي بجوار آخر موقع لرأس الثعبان.
int age[8][8] = {};

// --------------------------------------------------------------- //
// ------------------------- الدوال المساعدة --------------------- //
// --------------------------------------------------------------- //

// إذا لم يكن هناك طعام، قم بإنشائه، وتحقق أيضًا من حالة الفوز
void generateFood() {
  if (food.row == -1 || food.col == -1) {
    // إذا كان طول الثعبان يساوي أو يتجاوز 64، يتم الفوز
    if (snakeLength >= 64) {
      win = true;
      return; // منع توليد الطعام إذا تم الفوز
    }

    // توليد الطعام حتى يتم وضعه في مكان صحيح
    do {
      food.col = random(8);
      food.row = random(8);
    } while (age[food.row][food.col] > 0);
  }
}

// دالة لوغاريتمية عكسية مخصصة مع تدرج متغير
float lnx(float n) {
  if(n < 0) return 0;
  if(n > 1) return 1;
  n = -log(-n * logarithmity + 1); // لوغاريتم طبيعي
  if (isinf(n)) n = lnx(0.999999); // منع إرجاع 'inf'
  return n;
}

// مراقبة تحركات عصا التحكم وإضاءة الطعام
void scanJoystick() {
  int previousDirection = snakeDirection; // حفظ الاتجاه السابق
  long timestamp = millis() + snakeSpeed; // وقت عرض الإطار التالي

  while (millis() < timestamp) {
    // حساب سرعة الثعبان بشكل لوغاريتمي (10...1000ms)
    float raw = mapf(analogRead(Pin::potentiometer), 0, 1023, 0, 1);
    snakeSpeed = mapf(lnx(raw), lnx(0), lnx(1), 10, 1000);
    if (snakeSpeed == 0) snakeSpeed = 1; // التأكد من أن السرعة لا تساوي صفر

    // تحديد اتجاه الثعبان بناءً على حركة عصا التحكم
    analogRead(Pin::joystickY) < joystickHome.y - joystickThreshold ? snakeDirection = right : 0;
    analogRead(Pin::joystickY) > joystickHome.y + joystickThreshold ? snakeDirection = left  : 0;
    analogRead(Pin::joystickX) < joystickHome.x - joystickThreshold ? snakeDirection = up    : 0;
    analogRead(Pin::joystickX) > joystickHome.x + joystickThreshold ? snakeDirection = down  : 0;

    // تجاهل تغيير الاتجاه بمقدار 180 درجة (لا تأثير إذا كان الثعبان لا يتحرك)
    snakeDirection + 2 == previousDirection && previousDirection != 0 ? snakeDirection = previousDirection : 0;
    snakeDirection - 2 == previousDirection && previousDirection != 0 ? snakeDirection = previousDirection : 0;

    // إضاءة الطعام بشكل متقطع
    matrix.setLed(0, food.row, food.col, millis() % 100 < 50 ? 1 : 1);
  }
}

// حساب حركة الثعبان
void calculateSnake() {
  switch (snakeDirection) {
  case up:
    snake.row--;
    fixEdge();
    matrix.setLed(0, snake.row, snake.col, 1);
    break;

  case right:
    snake.col++;
    fixEdge();
    matrix.setLed(0, snake.row, snake.col, 1);
    break;

  case down:
    snake.row++;
    fixEdge();
    matrix.setLed(0, snake.row, snake.col, 1);
    break;

  case left:
    snake.col--;
    fixEdge();
    matrix.setLed(0, snake.row, snake.col, 1);
    break;

  default: // إذا كان الثعبان لا يتحرك، يتم الخروج
    return;
  }

  // إذا كان هناك أي عمر (جسم الثعبان)، سيؤدي ذلك إلى انتهاء اللعبة (يجب أن يتحرك الثعبان)
  if (age[snake.row][snake.col] != 0 && snakeDirection != 0) {
    gamoverSound();
    gameOver = true;
    return;
  }

  // التحقق من أكل الطعام
  if (snake.row == food.row && snake.col == food.col) {
    beep(fH, 30);// صوت عند أكل الطعام
    snakeLength++;
    food.row = -1; // إعادة تعيين الطعام
    food.col = -1;
  }

  // زيادة عمر جميع البكسلات المضاءة
  updateAges();

  // تغيير عمر رأس الثعبان من 0 إلى 1
  age[snake.row][snake.col]++;
}

// إصلاح حواف المصفوفة لجعل الثعبان يظهر على الجانب الآخر إذا خرج من الحافة
void fixEdge() {
  snake.col < 0 ? snake.col += 8 : 0;
  snake.col > 7 ? snake.col -= 8 : 0;
  snake.row < 0 ? snake.row += 8 : 0;
  snake.row > 7 ? snake.row -= 8 : 0;
}

// زيادة عمر البكسلات المضاءة وإطفاء البكسلات القديمة بناءً على طول الثعبان
void updateAges() {
  for (int row = 0; row < 8; row++) {
    for (int col = 0; col < 8; col++) {
      // إذا كان البكسل مضاء، يتم زيادة عمره
      if (age[row][col] > 0 ) {
        age[row][col]++;
      }

      // إذا تجاوز العمر طول الثعبان، يتم إطفاؤه
      if (age[row][col] > snakeLength) {
        matrix.setLed(0, row, col, 0);
        age[row][col] = 0;
      }
    }
  }
}

// إدارة حالات اللعبة (الفوز أو الخسارة)
void handleGameStates() {
  if (gameOver || win) {
    unrollSnake(); // إظهار الثعبان بشكل متتالي
    showScoreMessage(snakeLength); // عرض النقاط

    if (gameOver) showGameOverMessage(); // عرض رسالة انتهاء اللعبة
    else if (win) showWinMessage(); // عرض رسالة الفوز

    // إعادة تهيئة اللعبة
    win = false;
    gameOver = false;
    snake.row = random(8);
    snake.col = random(8);
    food.row = -1;
    food.col = -1;
    snakeLength = initialSnakeLength;
    snakeDirection = 0;
    startSound();
    memset(age, 0, sizeof(age[0][0]) * 8 * 8);
    matrix.clearDisplay(0);
  }
}

// إظهار الثعبان بشكل متتالي عند انتهاء اللعبة
void unrollSnake() {
  // إطفاء LED الطعام
  matrix.setLed(0, food.row, food.col, 0);

  delay(600);

  for (int i = 1; i <= snakeLength; i++) {
    for (int row = 0; row < 8; row++) {
      for (int col = 0; col < 8; col++) {
        if (age[row][col] == i) {
          matrix.setLed(0, row, col, 0);
          delay(100);
        }
      }
    }
  }
}

// معايرة عصا التحكم
void calibrateJoystick() {
  Coordinate values;

  for (int i = 0; i < 10; i++) {
    values.x += analogRead(Pin::joystickX);
    values.y += analogRead(Pin::joystickY);
  }

  joystickHome.x = values.x / 10;
  joystickHome.y = values.y / 10;
}

// تهيئة المنافذ والمصفوفة
void initialize() {
  pinMode(Pin::joystickVCC, OUTPUT);
  digitalWrite(Pin::joystickVCC, HIGH);

  pinMode(Pin::joystickGND, OUTPUT);
  digitalWrite(Pin::joystickGND, LOW);

  matrix.shutdown(0, false);
  matrix.setIntensity(0, intensity);
  matrix.clearDisplay(0);

  randomSeed(analogRead(A5));
  snake.row = random(8);
  snake.col = random(8);
}

// اظهار  لوحة اللعبة الحالية في المنفذ التسلسلي
void dumpGameBoard() {
  String buff = "\n\n\n";
  for (int row = 0; row < 8; row++) {
    for (int col = 0; col < 8; col++) {
      if (age[row][col] < 10) buff += " ";
      if (age[row][col] != 0) buff += age[row][col];
      else if (col == food.col && row == food.row) buff += "@";
      else buff += "-";
      buff += " ";
    }
    buff += "\n";
  }
  Serial.println(buff);
}

// --------------------------------------------------------------- //
// ------------------------- الرسائل ----------------------------- //
// --------------------------------------------------------------- //

// رسالة "SNAKE" عند البدء
const PROGMEM bool hungrySnakeMessage[8][56] = {
  // s  n  a  k  e
  {0,1,1,1,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,1,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,0,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,1,1,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,1,0,1,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,1,0,1,0,0,0,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,1,1,1,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};

// رسالة "GAME OVER" عند الخسارة
const PROGMEM bool gameOverMessage[8][90] = {
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,1,1,0,0,0,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,0,0,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0}
};

// رسالة "SCORE" مع الأرقام
const PROGMEM bool scoreMessage[8][58] = {
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0}
};

// تعريف الأرقام (0-9)
const PROGMEM bool digits[][8][8] = {
  {
    {0,0,0,0,0,0,0,0},
    {0,0,1,1,1,1,0,0},
    {0,1,1,0,0,1,1,0},
    {0,1,1,0,1,1,1,0},
    {0,1,1,1,0,1,1,0},
    {0,1,1,0,0,1,1,0},
    {0,1,1,0,0,1,1,0},
    {0,0,1,1,1,1,0,0}
  },
  {
    {0,0,0,0,0,0,0,0},
    {0,0,0,1,1,0,0,0},
    {0,0,0,1,1,0,0,0},
    {0,0,1,1,1,0,0,0},
    {0,0,0,1,1,0,0,0},
    {0,0,0,1,1,0,0,0},
    {0,0,0,1,1,0,0,0},
    {0,1,1,1,1,1,1,0}
  },
  {
    {0,0,0,0,0,0,0,0},
    {0,0,1,1,1,1,0,0},
    {0,1,1,0,0,1,1,0},
    {0,0,0,0,0,1,1,0},
    {0,0,0,0,1,1,0,0},
    {0,0,1,1,0,0,0,0},
    {0,1,1,0,0,0,0,0},
    {0,1,1,1,1,1,1,0}
  },
  {
    {0,0,0,0,0,0,0,0},
    {0,0,1,1,1,1,0,0},
    {0,1,1,0,0,1,1,0},
    {0,0,0,0,0,1,1,0},
    {0,0,0,1,1,1,0,0},
    {0,0,0,0,0,1,1,0},
    {0,1,1,0,0,1,1,0},
    {0,0,1,1,1,1,0,0}
  },
  {
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,1,1,0,0},
    {0,0,0,1,1,1,0,0},
    {0,0,1,0,1,1,0,0},
    {0,1,0,0,1,1,0,0},
    {0,1,1,1,1,1,1,0},
    {0,0,0,0,1,1,0,0},
    {0,0,0,0,1,1,0,0}
  },
  {
    {0,0,0,0,0,0,0,0},
    {0,1,1,1,1,1,1,0},
    {0,1,1,0,0,0,0,0},
    {0,1,1,1,1,1,0,0},
    {0,0,0,0,0,1,1,0},
    {0,0,0,0,0,1,1,0},
    {0,1,1,0,0,1,1,0},
    {0,0,1,1,1,1,0,0}
  },
  {
    {0,0,0,0,0,0,0,0},
    {0,0,1,1,1,1,0,0},
    {0,1,1,0,0,1,1,0},
    {0,1,1,0,0,0,0,0},
    {0,1,1,1,1,1,0,0},
    {0,1,1,0,0,1,1,0},
    {0,1,1,0,0,1,1,0},
    {0,0,1,1,1,1,0,0}
  },
  {
    {0,0,0,0,0,0,0,0},
    {0,1,1,1,1,1,1,0},
    {0,1,1,0,0,1,1,0},
    {0,0,0,0,1,1,0,0},
    {0,0,0,0,1,1,0,0},
    {0,0,0,1,1,0,0,0},
    {0,0,0,1,1,0,0,0},
    {0,0,0,1,1,0,0,0}
  },
  {
    {0,0,0,0,0,0,0,0},
    {0,0,1,1,1,1,0,0},
    {0,1,1,0,0,1,1,0},
    {0,1,1,0,0,1,1,0},
    {0,0,1,1,1,1,0,0},
    {0,1,1,0,0,1,1,0},
    {0,1,1,0,0,1,1,0},
    {0,0,1,1,1,1,0,0}
  },
  {
    {0,0,0,0,0,0,0,0},
    {0,0,1,1,1,1,0,0},
    {0,1,1,0,0,1,1,0},
    {0,1,1,0,0,1,1,0},
    {0,0,1,1,1,1,1,0},
    {0,0,0,0,0,1,1,0},
    {0,1,1,0,0,1,1,0},
    {0,0,1,1,1,1,0,0}
  }
};

// عرض رسالة "SNAKE"
void showSnakeMessage() {
  for (int d = 0; d < sizeof(hungrySnakeMessage[0]) - 7; d++) {
    for (int col = 0; col < 8; col++) {
      delay(messageSpeed);
      for (int row = 0; row < 8; row++) {
        matrix.setLed(0, row, col, pgm_read_byte(&(hungrySnakeMessage[row][col + d])));
      }
    }
  }
}

// عرض رسالة "GAME OVER"
void showGameOverMessage() {
  for (int d = 0; d < sizeof(gameOverMessage[0]) - 7; d++) {
    for (int col = 0; col < 8; col++) {
      delay(messageSpeed);
      for (int row = 0; row < 8; row++) {
        matrix.setLed(0, row, col, pgm_read_byte(&(gameOverMessage[row][col + d])));
      }
    }
  }
}

// عرض رسالة "WIN" (غير مطبقة بعد)
void showWinMessage() {
  // TODO: تنفيذ هذه الوظيفة
}

// عرض رسالة "SCORE" مع الأرقام
void showScoreMessage(int score) {
  if (score < 0 || score > 99) return;

  // تحديد أرقام النقاط
  int second = score % 10;
  int first = (score / 10) % 10;

  for (int d = 0; d < sizeof(scoreMessage[0]) + 2 * sizeof(digits[0][0]); d++) {
    for (int col = 0; col < 8; col++) {
      delay(messageSpeed);
      for (int row = 0; row < 8; row++) {
        if (d <= sizeof(scoreMessage[0]) - 8) {
          matrix.setLed(0, row, col, pgm_read_byte(&(scoreMessage[row][col + d])));
        }

        int c = col + d - sizeof(scoreMessage[0]) + 6; // تحريك 6 بكسل أمام الرسالة السابقة

        // إذا كانت النقاط < 10، يتم إزاحة الرقم الأول (صفر)
        if (score < 10) c += 8;

        if (c >= 0 && c < 8) {
          if (first > 0) matrix.setLed(0, row, col, pgm_read_byte(&(digits[first][row][c]))); // عرض الرقم الأول إذا كانت النقاط >= 10
        } else {
          c -= 8;
          if (c >= 0 && c < 8) {
            matrix.setLed(0, row, col, pgm_read_byte(&(digits[second][row][c]))); // عرض الرقم الثاني دائمًا
          }
        }
      }
    }
  }
}

// دالة map مخصصة للتعامل مع الأعداد العشرية
float mapf(float x, float in_min, float in_max, float out_min, float out_max) {
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

// تشغيل صوت البداية
void startSound() {
  beep(c, 200);
  beep(d, 200);
  beep(f, 200);
  beep(gS, 800);
  beep(gSH, 32);
  beep(gH, 17);
  beep(fSH, 12);
  beep(fH, 12);    
  beep(fSH, 25);
}

// تشغيل صوت انتهاء اللعبة
void gamoverSound() {
  beep(f, 200);
  beep(f, 200);
  beep(f, 200);
  beep(c, 800);
  beep(gSH, 32);
  beep(gH, 27);
  beep(fSH, 22);
  beep(fH, 22);    
  beep(fSH, 25);
}

// تشغيل نغمة معينة
void beep(int note, int duration) {
  tone(Pin::buzzerPin, note, duration);
  delay(duration);
  noTone(Pin::buzzerPin);
  delay(10);
}